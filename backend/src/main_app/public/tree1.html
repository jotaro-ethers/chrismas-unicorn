<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Christmas Tree</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Poppins:wght@300;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: radial-gradient(ellipse at bottom, #1B2838 0%, #090A0F 100%);
            font-family: 'Poppins', sans-serif; 
        }
        #canvas-container { width: 100%; height: 100vh; position: fixed; top: 0; left: 0; }
        
        #welcome-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; background: radial-gradient(ellipse at bottom, #1B2838 0%, #090A0F 100%);
            transition: opacity 0.8s ease, visibility 0.8s;
        }
        #welcome-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        
        .snowflakes { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }
        .snowflake {
            position: absolute; color: #fff; font-size: 1.5em;
            animation: fall linear infinite;
            opacity: 0.8; text-shadow: 0 0 5px #fff;
        }
        @keyframes fall {
            0% { transform: translateY(-10vh) rotate(0deg); }
            100% { transform: translateY(110vh) rotate(360deg); }
        }
        
        .welcome-title {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(3rem, 10vw, 6rem);
            color: #FFD700;
            text-shadow: 0 0 20px rgba(255,215,0,0.5), 0 0 40px rgba(255,0,0,0.3);
            margin-bottom: 10px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 20px rgba(255,215,0,0.5), 0 0 40px rgba(255,0,0,0.3); }
            to { text-shadow: 0 0 30px rgba(255,215,0,0.8), 0 0 60px rgba(255,0,0,0.5); }
        }
        
        .welcome-subtitle {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: rgba(255,255,255,0.7);
            margin-bottom: 40px;
            font-weight: 300;
        }
        
        .gesture-guide {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 15px; max-width: 700px; padding: 0 20px; margin-bottom: 40px;
        }
        .gesture-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,215,0,0.2);
            border-radius: 15px; padding: 15px 10px;
            text-align: center; backdrop-filter: blur(10px);
            transition: transform 0.3s, border-color 0.3s;
        }
        .gesture-item:hover { transform: translateY(-5px); border-color: rgba(255,215,0,0.5); }
        .gesture-icon { font-size: 2rem; margin-bottom: 8px; }
        .gesture-name { color: #FFD700; font-size: 0.85rem; font-weight: 600; margin-bottom: 4px; }
        .gesture-desc { color: rgba(255,255,255,0.6); font-size: 0.75rem; }
        
        #btnStart {
            background: linear-gradient(135deg, #D32F2F 0%, #8B0000 100%);
            color: #FFF; border: 3px solid #FFD700;
            padding: 18px 60px; border-radius: 50px;
            font-weight: 600; font-size: 1.2rem; cursor: pointer;
            box-shadow: 0 0 30px rgba(255,0,0,0.4), 0 10px 30px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            text-transform: uppercase; letter-spacing: 2px;
        }
        #btnStart:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(255,0,0,0.6), 0 15px 40px rgba(0,0,0,0.4);
        }
        
        #copyright { position: absolute; bottom: 15px; right: 20px; color: rgba(255,255,255,0.3); font-size: 12px; font-style: italic; }
        #debug { position: fixed; top: 10px; left: 10px; color: #0f0; font-size: 11px; z-index: 100; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; font-family: monospace; display: none; }
        #camera-preview { position: fixed; top: 10px; right: 10px; width: 160px; height: 120px; border: 2px solid rgba(255,215,0,0.5); border-radius: 12px; transform: scaleX(-1); opacity: 0; z-index: 100; transition: opacity 0.5s; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
        #camera-preview.visible { opacity: 0.8; }
        #camera-preview.debug-hidden { opacity: 0 !important; pointer-events: none; }
        #debug.debug-hidden { display: none !important; }
        #debug-btn { position: fixed; top: 140px; right: 10px; width: 50px; height: 24px; border-radius: 12px; border: none; cursor: pointer; z-index: 101; font-size: 10px; font-weight: 600; transition: all 0.3s; display: none; }
        #debug-btn.on { background: rgba(255,215,0,0.8); color: #000; }
        #debug-btn.off { background: rgba(100,100,100,0.6); color: #fff; }
        .mini-guide { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.5); font-size: 12px; z-index: 100; text-align: center; display: none; }
    </style>
</head>
<body>
    <div id="welcome-screen">
        <div class="snowflakes"></div>
        <h1 class="welcome-title">Classic Christmas</h1>
        <p class="welcome-subtitle">Traditional Red & Gold Theme</p>
        
        <div class="gesture-guide">
            <div class="gesture-item"><div class="gesture-icon">‚úä</div><div class="gesture-name">Fist</div><div class="gesture-desc">Christmas Tree</div></div>
            <div class="gesture-item"><div class="gesture-icon">üñê</div><div class="gesture-name">Open Hand</div><div class="gesture-desc">Explode</div></div>
            <div class="gesture-item"><div class="gesture-icon">‚òùÔ∏è</div><div class="gesture-name">Point</div><div class="gesture-desc">Rotate ‚Üë‚Üì‚Üê‚Üí</div></div>
            <div class="gesture-item"><div class="gesture-icon">ü´∂</div><div class="gesture-name">2 Hands</div><div class="gesture-desc">Heart</div></div>
            <div class="gesture-item"><div class="gesture-icon">ü§è</div><div class="gesture-name">Pinch</div><div class="gesture-desc">View Photo</div></div>
        </div>
        
        <button id="btnStart" onclick="startSystem()">Start Magic</button>
        <div id="copyright">by vandiep</div>
    </div>
    
    <div id="debug">Loading...</div>
    <video id="camera-preview" autoplay playsinline></video>
    <button id="debug-btn" class="on" onclick="toggleDebug()">ON</button>
    <div class="mini-guide">‚úä Tree | üñê Explode | ‚òùÔ∏è Rotate 4D | ü´∂ Heart | ü§è Photo</div>
    <div id="canvas-container"></div>

    <script>
        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.007, dCutoff = 1.0) { this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff; this.xPrev = null; this.dxPrev = 0; }
            smoothingFactor(te, cutoff) { const r = 2 * Math.PI * cutoff * te; return r / (r + 1); }
            filter(x, te = 1/30) {
                if (this.xPrev === null) { this.xPrev = x; return x; }
                const dx = (x - this.xPrev) / te;
                const edx = this.smoothingFactor(te, this.dCutoff) * dx + (1 - this.smoothingFactor(te, this.dCutoff)) * this.dxPrev;
                this.dxPrev = edx;
                const cutoff = this.minCutoff + this.beta * Math.abs(edx);
                const result = this.smoothingFactor(te, cutoff) * x + (1 - this.smoothingFactor(te, cutoff)) * this.xPrev;
                this.xPrev = result;
                return result;
            }
        }

        let state = 'TREE', selectedIndex = 0, currentRotationSpeedY = 0, currentRotationSpeedX = 0, pointDirectionX = 0, pointDirectionY = 0;
        const handXFilter = new OneEuroFilter(1.0, 0.01, 1.0);
        let lastTime = performance.now(), stateBuffer = [];
        const STATE_BUFFER_SIZE = 5;
        let handLandmarker = null, video = null, isRunning = false;
        let scene, camera, renderer, groupGold, groupRed, groupGift, photoMeshes = [], titleMesh, starMesh, loveMesh;
        
        // CONFIG: Change PHOTO_COUNT to match your number of images
        const PHOTO_COUNT = 20; // Change this number to load more/fewer photos
        const CONFIG = { goldCount: 2000, redCount: 300, giftCount: 150, explodeRadius: 65, photoOrbitRadius: 25, treeHeight: 70, treeBaseRadius: 35 };

        const loader = new THREE.TextureLoader();
        const photoTextures = [];
        for (let i = 1; i <= PHOTO_COUNT; i++) {
            photoTextures.push(loader.load(`../M√™ Ry Ch√≠ M·ªõt/image${i}.jpeg`));
        }

        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64;
            if (type === 'gold') {
                const g = ctx.createRadialGradient(cx,cx,0,cx,cx,40);
                g.addColorStop(0,'#FFF'); g.addColorStop(0.2,'#FFFFE0');
                g.addColorStop(0.5,'#FFD700'); g.addColorStop(1,'transparent');
                ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
            } else if (type === 'red') {
                const g = ctx.createRadialGradient(cx,cx,0,cx,cx,50);
                g.addColorStop(0,'#FAA'); g.addColorStop(0.3,'#F00'); g.addColorStop(1,'transparent');
                ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
            } else {
                ctx.fillStyle = '#D32F2F'; ctx.fillRect(20,20,88,88);
                ctx.fillStyle = '#FFD700'; ctx.fillRect(54,20,20,88); ctx.fillRect(20,54,88,20);
            }
            return new THREE.CanvasTexture(canvas);
        }
        const textures = { gold: createTexture('gold'), red: createTexture('red'), gift: createTexture('gift') };

        async function initHandDetection() {
            const debug = document.getElementById('debug');
            try {
                debug.innerHTML = 'Loading MediaPipe...';
                const { FilesetResolver, HandLandmarker } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14");
                debug.innerHTML = 'Loading WASM...';
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
                debug.innerHTML = 'Loading Hand Model...';
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 2, minHandDetectionConfidence: 0.5, minHandPresenceConfidence: 0.5, minTrackingConfidence: 0.5
                });
                debug.innerHTML = 'Requesting Camera...';
                video = document.getElementById('camera-preview');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: 'user' } });
                video.srcObject = stream;
                await video.play();
                debug.innerHTML = 'Ready!';
                isRunning = true;
                detectHands();
            } catch (err) { debug.innerHTML = 'Error: ' + err.message; console.error(err); }
        }

        function detectHands() {
            if (!isRunning) return;
            const now = performance.now();
            const te = (now - lastTime) / 1000;
            lastTime = now;
            const results = handLandmarker.detectForVideo(video, now);
            let newState = 'TREE';
            pointDirectionX = 0;
            pointDirectionY = 0;
            
            if (results.landmarks && results.landmarks.length > 0) {
                if (results.landmarks.length === 2) {
                    const h1 = results.landmarks[0], h2 = results.landmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    if (distIndex < 0.15 && distThumb < 0.15) newState = 'HEART';
                }
                if (newState !== 'HEART') {
                    const lm = results.landmarks[0], wrist = lm[0];
                    const fingerTips = [4, 8, 12, 16, 20], fingerMcps = [2, 5, 9, 13, 17];
                    const fingerPips = [3, 6, 10, 14, 18]; // PIP joints for better curl detection
                    let fingersOpen = 0, openFingerTip = null;
                    
                    // Calculate palm center for better fist detection
                    const palmCenter = {
                        x: (lm[0].x + lm[5].x + lm[17].x) / 3,
                        y: (lm[0].y + lm[5].y + lm[17].y) / 3
                    };
                    
                    fingerTips.forEach((tip, idx) => {
                        const mcp = fingerMcps[idx];
                        const pip = fingerPips[idx];
                        
                        // Method 1: tip distance from wrist vs mcp distance
                        const tipDist = Math.hypot(lm[tip].x - wrist.x, lm[tip].y - wrist.y);
                        const mcpDist = Math.hypot(lm[mcp].x - wrist.x, lm[mcp].y - wrist.y);
                        
                        // Method 2: check if finger is curled (tip closer to palm than pip)
                        const tipToPalm = Math.hypot(lm[tip].x - palmCenter.x, lm[tip].y - palmCenter.y);
                        const pipToPalm = Math.hypot(lm[pip].x - palmCenter.x, lm[pip].y - palmCenter.y);
                        
                        // Finger is open if: tip is far from wrist AND tip is farther from palm than pip
                        const isExtended = tipDist > mcpDist * 1.3;
                        const isNotCurled = tipToPalm > pipToPalm * 0.9;
                        
                        if (isExtended && isNotCurled) { 
                            fingersOpen++; 
                            openFingerTip = lm[tip]; 
                        }
                    });
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    if (fingersOpen === 1 && openFingerTip) {
                        newState = 'POINTING';
                        const fingerDirX = openFingerTip.x - wrist.x;
                        const fingerDirY = openFingerTip.y - wrist.y;
                        if (fingerDirX < -0.08) pointDirectionX = 1;
                        else if (fingerDirX > 0.08) pointDirectionX = -1;
                        if (fingerDirY < -0.08) pointDirectionY = -1;
                        else if (fingerDirY > 0.08) pointDirectionY = 1;
                    } else if (fingersOpen <= 1) newState = 'TREE';
                    else if (pinchDist < 0.06) newState = 'PHOTO';
                    else newState = 'EXPLODE';
                }
            }
            stateBuffer.push(newState);
            if (stateBuffer.length > STATE_BUFFER_SIZE) stateBuffer.shift();
            const stateCount = {};
            stateBuffer.forEach(s => stateCount[s] = (stateCount[s] || 0) + 1);
            const dominant = Object.entries(stateCount).sort((a,b) => b[1] - a[1])[0];
            if (dominant && dominant[1] >= 3) state = dominant[0];
            const dirXStr = pointDirectionX === 1 ? 'R' : pointDirectionX === -1 ? 'L' : '-';
            const dirYStr = pointDirectionY === 1 ? 'D' : pointDirectionY === -1 ? 'U' : '-';
            document.getElementById('debug').innerHTML = 'State: ' + state + '<br>Dir: ' + dirXStr + '/' + dirYStr + '<br>FPS: ' + (1/te).toFixed(0);
            requestAnimationFrame(detectHands);
        }

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);
            camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            groupGold = createParticles('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticles('red', CONFIG.redCount, 3.5);
            groupGift = createParticles('gift', CONFIG.giftCount, 3.0);
            createPhotos();
            createDecorations();
            animate();
        }

        function createParticles(type, count, size) {
            const positions = [], treeTargets = [], explodeTargets = [], heartTargets = [], phases = [];
            for (let i = 0; i < count; i++) {
                const h = Math.random() * CONFIG.treeHeight;
                const y = h - CONFIG.treeHeight / 2;
                const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
                const r = maxR * (type === 'gold' ? Math.sqrt(Math.random()) : 0.9 + Math.random() * 0.1);
                const theta = Math.random() * Math.PI * 2;
                treeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));
                const phi = Math.acos(2 * Math.random() - 1);
                const lam = Math.random() * Math.PI * 2;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * (type === 'gift' ? 1.2 : 1);
                explodeTargets.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));
                const t = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                const fill = Math.pow(Math.random(), 0.3);
                heartTargets.push(hx * fill * 2.2, hy * fill * 2.2 + 5, (Math.random() - 0.5) * 8 * fill);
                positions.push(...treeTargets.slice(-3));
                phases.push(Math.random() * Math.PI * 2);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const colors = new Float32Array(count * 3);
            const baseColor = new THREE.Color(type === 'gold' ? 0xFFD700 : type === 'red' ? 0xFF0000 : 0xFFFFFF);
            for (let i = 0; i < count; i++) { colors[i*3] = baseColor.r; colors[i*3+1] = baseColor.g; colors[i*3+2] = baseColor.b; }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.userData = { tree: treeTargets, explode: explodeTargets, heart: heartTargets, phases, baseColor, baseSize: size };
            const mat = new THREE.PointsMaterial({ size, map: textures[type], transparent: true, vertexColors: true, blending: type === 'gift' ? THREE.NormalBlending : THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            const geo = new THREE.PlaneGeometry(8, 8);
            const borderGeo = new THREE.PlaneGeometry(9, 9);
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            for (let i = 0; i < PHOTO_COUNT; i++) {
                const mat = new THREE.MeshBasicMaterial({ map: photoTextures[i], side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geo, mat);
                const border = new THREE.Mesh(borderGeo, borderMat);
                border.position.z = -0.1;
                mesh.add(border);
                mesh.visible = false;
                mesh.scale.set(0, 0, 0);
                scene.add(mesh);
                photoMeshes.push(mesh);
            }
        }

        function createDecorations() {
            const c1 = document.createElement('canvas');
            c1.width = 1024; c1.height = 256;
            const ctx1 = c1.getContext('2d');
            ctx1.font = 'bold italic 90px "Times New Roman"';
            ctx1.fillStyle = '#FFD700'; ctx1.textAlign = 'center';
            ctx1.shadowColor = '#F00'; ctx1.shadowBlur = 40;
            ctx1.fillText('MERRY CHRISTMAS', 512, 130);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c1), transparent: true, blending: THREE.AdditiveBlending }));
            titleMesh.position.set(0, 50, 0);
            scene.add(titleMesh);
            
            const c2 = document.createElement('canvas');
            c2.width = c2.height = 128;
            const ctx2 = c2.getContext('2d');
            ctx2.fillStyle = '#FF0'; ctx2.shadowColor = '#FFF'; ctx2.shadowBlur = 20;
            ctx2.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx2.lineTo(64 + Math.cos((18 + i*72) * Math.PI/180) * 50, 64 - Math.sin((18 + i*72) * Math.PI/180) * 50);
                ctx2.lineTo(64 + Math.cos((54 + i*72) * Math.PI/180) * 20, 64 - Math.sin((54 + i*72) * Math.PI/180) * 20);
            }
            ctx2.closePath(); ctx2.fill();
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c2), transparent: true, blending: THREE.AdditiveBlending }));
            starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            scene.add(starMesh);
            
            const c3 = document.createElement('canvas');
            c3.width = 1024; c3.height = 256;
            const ctx3 = c3.getContext('2d');
            ctx3.font = 'bold 120px "Segoe UI"';
            ctx3.fillStyle = '#FF69B4'; ctx3.textAlign = 'center';
            ctx3.shadowColor = '#FF1493'; ctx3.shadowBlur = 40;
            ctx3.fillText('I LOVE YOU', 512, 130);
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 18), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c3), transparent: true, blending: THREE.AdditiveBlending }));
            loveMesh.position.set(0, 0, 20);
            loveMesh.visible = false;
            scene.add(loveMesh);
        }

        function updateParticles(group, type, targetState, speed, time) {
            const pos = group.geometry.attributes.position.array;
            const colors = group.geometry.attributes.color.array;
            const { tree, explode, heart, phases, baseColor } = group.geometry.userData;
            const targets = targetState === 'TREE' ? tree : targetState === 'HEART' ? heart : explode;
            for (let i = 0; i < pos.length; i++) pos[i] += (targets[i] - pos[i]) * speed;
            group.geometry.attributes.position.needsUpdate = true;
            const count = pos.length / 3;
            if (targetState === 'TREE') {
                const breathe = 1 + Math.sin(time * 0.8) * 0.03;
                group.scale.set(breathe, breathe, breathe);
                group.rotation.x = 0; group.rotation.y = 0; group.rotation.z = 0; group.position.y = 0;
            } else if (targetState === 'HEART') {
                group.rotation.x *= 0.9; group.rotation.y *= 0.9;
                const beat = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
                group.scale.set(beat, beat, beat);
            } else {
                group.scale.set(1, 1, 1);
                group.rotation.y += currentRotationSpeedY;
                group.rotation.x += currentRotationSpeedX;
            }
            for (let i = 0; i < count; i++) {
                let b = 1;
                if (targetState === 'TREE') b = type === 'red' ? 0.5 + 0.5 * Math.sin(time * 3 + phases[i]) : type === 'gold' ? 0.8 + 0.4 * Math.sin(time * 10 + phases[i]) : 1;
                else if (targetState !== 'HEART') b = (type === 'gold' || type === 'red') ? 0.8 + 0.5 * Math.sin(time * 12 + phases[i]) : 1;
                colors[i*3] = baseColor.r * b; colors[i*3+1] = baseColor.g * b; colors[i*3+2] = baseColor.b * b;
            }
            group.geometry.attributes.color.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            let targetSpeedY = 0, targetSpeedX = 0;
            if (state === 'POINTING') {
                if (pointDirectionX !== 0) targetSpeedY = pointDirectionX * 0.008;
                if (pointDirectionY !== 0) targetSpeedX = pointDirectionY * 0.006;
            }
            currentRotationSpeedY = currentRotationSpeedY * 0.95 + targetSpeedY * 0.05;
            currentRotationSpeedX = currentRotationSpeedX * 0.95 + targetSpeedX * 0.05;
            const visualState = (state === 'POINTING') ? 'EXPLODE' : state;
            updateParticles(groupGold, 'gold', visualState, 0.08, time);
            updateParticles(groupRed, 'red', visualState, 0.08, time);
            updateParticles(groupGift, 'gift', visualState, 0.08, time);
            
            if (state === 'TREE') {
                titleMesh.visible = starMesh.visible = true; loveMesh.visible = false;
                titleMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                starMesh.rotation.z -= 0.02;
                starMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 5);
                photoMeshes.forEach(m => { m.visible = false; m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); });
            } else if (state === 'HEART') {
                titleMesh.visible = starMesh.visible = false; loveMesh.visible = true;
                photoMeshes.forEach(m => m.visible = false);
                const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
                loveMesh.scale.set(s, s, 1);
            } else if (state === 'EXPLODE' || state === 'POINTING') {
                titleMesh.visible = starMesh.visible = loveMesh.visible = false;
                // Dynamic orbit radius based on photo count
                const dynamicRadius = CONFIG.photoOrbitRadius + Math.max(0, (PHOTO_COUNT - 5) * 2);
                // Dynamic photo scale (smaller photos when there are many)
                const basePhotoScale = PHOTO_COUNT <= 5 ? 1 : Math.max(0.5, 1 - (PHOTO_COUNT - 5) * 0.04);
                let bestIdx = 0, maxZ = -999;
                
                // Apply rotation from pointing gesture
                const rotY = groupGold.rotation.y;
                const rotX = groupGold.rotation.x;
                
                photoMeshes.forEach((m, i) => {
                    m.visible = true;
                    
                    // Fibonacci sphere distribution for even spacing
                    const phi = Math.acos(1 - 2 * (i + 0.5) / PHOTO_COUNT);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i;
                    
                    // Base position on sphere
                    let x = Math.sin(phi) * Math.cos(theta) * dynamicRadius;
                    let y = Math.sin(phi) * Math.sin(theta) * dynamicRadius;
                    let z = Math.cos(phi) * dynamicRadius;
                    
                    // Apply rotation from gesture
                    const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
                    const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
                    
                    // Rotate around Y axis
                    const x1 = x * cosY + z * sinY;
                    const z1 = -x * sinY + z * cosY;
                    
                    // Rotate around X axis
                    const y2 = y * cosX - z1 * sinX;
                    const z2 = y * sinX + z1 * cosX;
                    
                    m.position.lerp(new THREE.Vector3(x1, y2, z2), 0.1);
                    m.lookAt(camera.position);
                    
                    if (z2 > maxZ) { maxZ = z2; bestIdx = i; }
                    const scale = (z2 > 0 ? 0.8 + (z2 / dynamicRadius) * 0.6 : 0.4) * basePhotoScale;
                    m.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.1);
                });
                selectedIndex = bestIdx;
            } else if (state === 'PHOTO') {
                loveMesh.visible = false;
                photoMeshes.forEach((m, i) => {
                    if (i === selectedIndex) { m.position.lerp(new THREE.Vector3(0, 0, 60), 0.1); m.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1); m.lookAt(camera.position); }
                    else m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                });
            }
            renderer.render(scene, camera);
        }

        async function startSystem() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('debug').style.display = 'block';
            document.getElementById('camera-preview').classList.add('visible');
            document.getElementById('debug-btn').style.display = 'block';
            document.querySelector('.mini-guide').style.display = 'block';
            const music = new Audio('../M√™ Ry Ch√≠ M·ªõt/audio.mp3');
            music.loop = true; music.volume = 0.7; music.play().catch(() => {});
            init3D();
            await initHandDetection();
        }

        let debugVisible = true;
        function toggleDebug() {
            debugVisible = !debugVisible;
            const btn = document.getElementById('debug-btn');
            const debug = document.getElementById('debug');
            const camera = document.getElementById('camera-preview');
            if (debugVisible) {
                btn.textContent = 'ON';
                btn.className = 'on';
                debug.classList.remove('debug-hidden');
                camera.classList.remove('debug-hidden');
            } else {
                btn.textContent = 'OFF';
                btn.className = 'off';
                debug.classList.add('debug-hidden');
                camera.classList.add('debug-hidden');
            }
        }

        function createSnowflakes() {
            const container = document.querySelector('.snowflakes');
            const flakes = ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº'];
            for (let i = 0; i < 50; i++) {
                const flake = document.createElement('div');
                flake.className = 'snowflake';
                flake.textContent = flakes[Math.floor(Math.random() * flakes.length)];
                flake.style.left = Math.random() * 100 + '%';
                flake.style.animationDuration = (Math.random() * 5 + 5) + 's';
                flake.style.animationDelay = Math.random() * 5 + 's';
                flake.style.fontSize = (Math.random() * 1 + 0.5) + 'em';
                flake.style.opacity = Math.random() * 0.5 + 0.3;
                container.appendChild(flake);
            }
        }
        createSnowflakes();
        window.addEventListener('resize', () => { if (camera) { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); } });
    </script>
</body>
</html>