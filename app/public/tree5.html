<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rainbow Magic Christmas | OurXmas</title>
    <meta name="description" content="Experience a colorful rainbow magic 3D Christmas tree with hand gesture controls. Create unforgettable holiday memories with your loved ones.">
    <meta name="keywords" content="Christmas, 3D Christmas tree, rainbow, colorful, magic, interactive, hand gestures, holiday, festive">
    <meta name="author" content="OurXmas">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Rainbow Magic Christmas | OurXmas">
    <meta property="og:description" content="Experience a colorful rainbow magic 3D Christmas tree with hand gesture controls.">
    <meta property="og:image" content="https://ourxmas.pics/preview/rainbow.jpg">
    <meta property="og:url" content="https://ourxmas.pics">
    <meta property="og:site_name" content="OurXmas">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Rainbow Magic Christmas | OurXmas">
    <meta name="twitter:description" content="Experience a colorful rainbow magic 3D Christmas tree with hand gesture controls.">
    <meta name="twitter:image" content="https://ourxmas.pics/preview/rainbow.jpg">
    
    <!-- Theme Color -->
    <meta name="theme-color" content="#1a1030">
    <meta name="msapplication-TileColor" content="#1a1030">
    
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÑ</text></svg>">
    
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Poppins:wght@300;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: radial-gradient(ellipse at bottom, #1a1030 0%, #050510 100%);
            font-family: 'Poppins', sans-serif; 
        }
        #canvas-container { width: 100%; height: 100vh; position: fixed; top: 0; left: 0; }
        
        #welcome-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; background: radial-gradient(ellipse at bottom, #1a1030 0%, #050510 100%);
            transition: opacity 0.8s ease, visibility 0.8s;
        }
        #welcome-screen.hidden { opacity: 0; visibility: hidden; pointer-events: none; }
        
        .snowflakes { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; }
        .snowflake {
            position: absolute; font-size: 1.5em;
            animation: fall linear infinite, rainbow 3s linear infinite;
            opacity: 0.8;
        }
        @keyframes fall {
            0% { transform: translateY(-10vh) rotate(0deg); }
            100% { transform: translateY(110vh) rotate(360deg); }
        }
        @keyframes rainbow {
            0% { color: #ff0000; text-shadow: 0 0 10px #ff0000; }
            17% { color: #ff8800; text-shadow: 0 0 10px #ff8800; }
            33% { color: #ffff00; text-shadow: 0 0 10px #ffff00; }
            50% { color: #00ff00; text-shadow: 0 0 10px #00ff00; }
            67% { color: #0088ff; text-shadow: 0 0 10px #0088ff; }
            83% { color: #8800ff; text-shadow: 0 0 10px #8800ff; }
            100% { color: #ff0000; text-shadow: 0 0 10px #ff0000; }
        }
        
        .welcome-title {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(3rem, 10vw, 6rem);
            background: linear-gradient(90deg, #ff0000, #ff8800, #ffff00, #00ff00, #0088ff, #8800ff, #ff0000);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbowText 3s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes rainbowText {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }
        
        .welcome-subtitle {
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: rgba(255,255,255,0.7);
            margin-bottom: 40px;
            font-weight: 300;
        }
        
        .gesture-guide {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            max-width: 100%;
            padding: 0 20px;
            margin-bottom: 40px;
            overflow-x: auto;
            justify-content: center;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        .gesture-guide::-webkit-scrollbar { display: none; }
        .gesture-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px 10px;
            text-align: center;
            backdrop-filter: blur(10px);
            transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
            animation: borderRainbow 5s linear infinite;
            flex: 0 0 auto;
            min-width: 80px;
        }
        @keyframes borderRainbow {
            0% { border-color: rgba(255,0,0,0.5); }
            17% { border-color: rgba(255,136,0,0.5); }
            33% { border-color: rgba(255,255,0,0.5); }
            50% { border-color: rgba(0,255,0,0.5); }
            67% { border-color: rgba(0,136,255,0.5); }
            83% { border-color: rgba(136,0,255,0.5); }
            100% { border-color: rgba(255,0,0,0.5); }
        }
        .gesture-item:hover { transform: translateY(-3px); box-shadow: 0 0 20px rgba(255,255,255,0.3); }
        .gesture-icon { font-size: 1.5rem; margin-bottom: 5px; }
        .gesture-name { color: #fff; font-size: 0.75rem; font-weight: 600; margin-bottom: 2px; }
        .gesture-desc { color: rgba(255,255,255,0.6); font-size: 0.65rem; }
        
        @media (max-width: 600px) {
            .gesture-guide { justify-content: flex-start; padding: 0 15px; }
            .gesture-item { min-width: 70px; padding: 10px 8px; }
            .gesture-icon { font-size: 1.3rem; }
            .gesture-name { font-size: 0.7rem; }
            .gesture-desc { font-size: 0.6rem; }
        }
        
        #btnStart {
            background: linear-gradient(90deg, #ff0000, #ff8800, #ffff00, #00ff00, #0088ff, #8800ff);
            background-size: 200% auto;
            color: #FFF; border: 3px solid #FFF;
            padding: 18px 60px; border-radius: 50px;
            font-weight: 600; font-size: 1.2rem; cursor: pointer;
            box-shadow: 0 0 30px rgba(255,255,255,0.3);
            transition: all 0.3s ease;
            text-transform: uppercase; letter-spacing: 2px;
            animation: rainbowText 3s linear infinite;
        }
        #btnStart:hover {
            transform: scale(1.05);
            box-shadow: 0 0 50px rgba(255,255,255,0.5);
        }
        
        #copyright { position: absolute; bottom: 15px; right: 20px; color: rgba(255,255,255,0.3); font-size: 12px; font-style: italic; }
        #debug { position: fixed; top: 10px; left: 10px; color: #0f0; font-size: 11px; z-index: 100; background: rgba(0,0,0,0.7); padding: 8px 12px; border-radius: 8px; font-family: monospace; display: none; }
        #camera-preview { position: fixed; top: 10px; right: 10px; width: 160px; height: 120px; border: 2px solid rgba(255,255,255,0.5); border-radius: 12px; transform: scaleX(-1); opacity: 0; z-index: 100; transition: opacity 0.5s; box-shadow: 0 5px 20px rgba(0,0,0,0.5); }
        #camera-preview.visible { opacity: 0.8; }
        #camera-preview.debug-hidden { opacity: 0 !important; pointer-events: none; }
        #debug.debug-hidden { display: none !important; }
        #debug-btn { position: fixed; top: 140px; right: 10px; width: 50px; height: 24px; border-radius: 12px; border: none; cursor: pointer; z-index: 101; font-size: 10px; font-weight: 600; transition: all 0.3s; display: none; }
        #debug-btn.on { background: linear-gradient(90deg, #ff0000, #ff8800, #ffff00, #00ff00, #0088ff); color: #000; }
        #debug-btn.off { background: rgba(100,100,100,0.6); color: #fff; }
        .mini-guide { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.5); font-size: 12px; z-index: 100; text-align: center; display: none; }
        
        /* Main snow effect container */
        #main-snowflakes { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden; z-index: 50; display: none; }
        #main-snowflakes .snowflake {
            position: absolute; font-size: 1.5em;
            animation: fall linear infinite, rainbow 3s linear infinite;
            opacity: 0.8;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 768px) {
            #camera-preview { width: 120px; height: 90px; top: 5px; right: 5px; }
            #debug { font-size: 9px; padding: 5px 8px; top: 5px; left: 5px; }
            #debug-btn { top: 100px; right: 5px; width: 40px; height: 20px; font-size: 8px; }
            .mini-guide { font-size: 10px; bottom: 10px; padding: 0 10px; }
            #btnStart { padding: 14px 40px; font-size: 1rem; letter-spacing: 1px; }
            .welcome-subtitle { margin-bottom: 25px; }
        }
        
        @media (max-width: 480px) {
            #camera-preview { width: 100px; height: 75px; }
            #debug { font-size: 8px; padding: 4px 6px; max-width: 100px; }
            #debug-btn { top: 85px; width: 35px; height: 18px; font-size: 7px; }
            .mini-guide { font-size: 8px; white-space: nowrap; overflow-x: auto; max-width: 100%; }
            #btnStart { padding: 12px 30px; font-size: 0.9rem; }
            .welcome-title { margin-bottom: 5px; }
            .welcome-subtitle { font-size: 0.9rem; margin-bottom: 20px; }
        }
        
        @media (max-height: 600px) {
            .welcome-title { font-size: clamp(2rem, 8vw, 4rem); }
            .welcome-subtitle { margin-bottom: 15px; }
            .gesture-guide { margin-bottom: 20px; }
            .gesture-item { padding: 8px 6px; min-width: 60px; }
            .gesture-icon { font-size: 1.2rem; }
            #btnStart { padding: 12px 35px; }
        }
    </style>
</head>
<body>
    <div id="welcome-screen">
        <div class="snowflakes"></div>
        <h1 class="welcome-title">Rainbow Magic</h1>
        <p class="welcome-subtitle">Color-Changing Fantasy Theme</p>
        
        <div class="gesture-guide">
            <div class="gesture-item"><div class="gesture-icon">‚úä</div><div class="gesture-name">Fist</div><div class="gesture-desc">Christmas Tree</div></div>
            <div class="gesture-item"><div class="gesture-icon">üñê</div><div class="gesture-name">Open Hand</div><div class="gesture-desc">Explode</div></div>
            <div class="gesture-item"><div class="gesture-icon">‚òùÔ∏è</div><div class="gesture-name">Point</div><div class="gesture-desc">Rotate ‚Üë‚Üì‚Üê‚Üí</div></div>
            <div class="gesture-item"><div class="gesture-icon">ü´∂</div><div class="gesture-name">2 Hands</div><div class="gesture-desc">Heart</div></div>
            <div class="gesture-item"><div class="gesture-icon">ü§è</div><div class="gesture-name">Pinch</div><div class="gesture-desc">View Photo</div></div>
        </div>
        
        <button id="btnStart" onclick="startSystem()">Start Magic</button>
    </div>
    
    <div id="debug">Loading...</div>
    <video id="camera-preview" autoplay playsinline></video>
    <button id="debug-btn" class="on" onclick="toggleDebug()">ON</button>
    <div class="mini-guide">‚úä Tree | üñê Explode | ‚òùÔ∏è Rotate 4D | ü´∂ Heart | ü§è Photo</div>
    <div id="main-snowflakes"></div>
    <div id="youtube-player" style="position:absolute;top:-9999px;left:-9999px;"></div>
    <div id="canvas-container"></div>

    <script>
        class OneEuroFilter {
            constructor(minCutoff = 1.0, beta = 0.007, dCutoff = 1.0) { this.minCutoff = minCutoff; this.beta = beta; this.dCutoff = dCutoff; this.xPrev = null; this.dxPrev = 0; }
            smoothingFactor(te, cutoff) { const r = 2 * Math.PI * cutoff * te; return r / (r + 1); }
            filter(x, te = 1/30) {
                if (this.xPrev === null) { this.xPrev = x; return x; }
                const dx = (x - this.xPrev) / te;
                const edx = this.smoothingFactor(te, this.dCutoff) * dx + (1 - this.smoothingFactor(te, this.dCutoff)) * this.dxPrev;
                this.dxPrev = edx;
                const cutoff = this.minCutoff + this.beta * Math.abs(edx);
                const result = this.smoothingFactor(te, cutoff) * x + (1 - this.smoothingFactor(te, cutoff)) * this.xPrev;
                this.xPrev = result;
                return result;
            }
        }

        let state = 'TREE', selectedIndex = 0, currentRotationSpeedY = 0, currentRotationSpeedX = 0, pointDirectionX = 0, pointDirectionY = 0;
        const handXFilter = new OneEuroFilter(1.0, 0.01, 1.0);
        let lastTime = performance.now(), stateBuffer = [];
        const STATE_BUFFER_SIZE = 5;
        let handLandmarker = null, video = null, isRunning = false;
        let scene, camera, renderer, groupGold, groupRed, groupGift, photoMeshes = [], titleMesh, starMesh, loveMesh;
        
        // CONFIG: Change PHOTO_COUNT to match your number of images
        const CONFIG = { goldCount: 2000, redCount: 300, giftCount: 150, explodeRadius: 65, photoOrbitRadius: 25, treeHeight: 70, treeBaseRadius: 35 };

        const loader = new THREE.TextureLoader();
        const photoTextures = [];
        for (let i = 1; i <= PHOTO_COUNT; i++) {
            photoTextures.push(loader.load(`./image${i}.jpeg`));
        }

        // RAINBOW THEME: Dynamic rainbow colors
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const cx = 64;
            if (type === 'gold') {
                const g = ctx.createRadialGradient(cx,cx,0,cx,cx,40);
                g.addColorStop(0,'#FFF'); g.addColorStop(0.2,'#FFF');
                g.addColorStop(0.5,'#FFF'); g.addColorStop(1,'transparent');
                ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
            } else if (type === 'red') {
                const g = ctx.createRadialGradient(cx,cx,0,cx,cx,50);
                g.addColorStop(0,'#FFF'); g.addColorStop(0.3,'#FFF'); g.addColorStop(1,'transparent');
                ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
            } else {
                ctx.fillStyle = '#FFF'; ctx.fillRect(20,20,88,88);
                ctx.fillStyle = '#FFF'; ctx.fillRect(54,20,20,88); ctx.fillRect(20,54,88,20);
            }
            return new THREE.CanvasTexture(canvas);
        }
        const textures = { gold: createTexture('gold'), red: createTexture('red'), gift: createTexture('gift') };

        async function initHandDetection() {
            const debug = document.getElementById('debug');
            try {
                debug.innerHTML = 'Loading MediaPipe...';
                const { FilesetResolver, HandLandmarker } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14");
                debug.innerHTML = 'Loading WASM...';
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm");
                debug.innerHTML = 'Loading Hand Model...';
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 2, minHandDetectionConfidence: 0.5, minHandPresenceConfidence: 0.5, minTrackingConfidence: 0.5
                });
                debug.innerHTML = 'Requesting Camera...';
                video = document.getElementById('camera-preview');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: 'user' } });
                video.srcObject = stream;
                await video.play();
                debug.innerHTML = 'Ready!';
                isRunning = true;
                detectHands();
            } catch (err) { debug.innerHTML = 'Error: ' + err.message; console.error(err); }
        }

        function detectHands() {
            if (!isRunning) return;
            const now = performance.now();
            const te = (now - lastTime) / 1000;
            lastTime = now;
            const results = handLandmarker.detectForVideo(video, now);
            let newState = 'TREE';
            pointDirectionX = 0;
            pointDirectionY = 0;
            
            if (results.landmarks && results.landmarks.length > 0) {
                if (results.landmarks.length === 2) {
                    const h1 = results.landmarks[0], h2 = results.landmarks[1];
                    const distIndex = Math.hypot(h1[8].x - h2[8].x, h1[8].y - h2[8].y);
                    const distThumb = Math.hypot(h1[4].x - h2[4].x, h1[4].y - h2[4].y);
                    if (distIndex < 0.15 && distThumb < 0.15) newState = 'HEART';
                }
                if (newState !== 'HEART') {
                    const lm = results.landmarks[0], wrist = lm[0];
                    const fingerTips = [4, 8, 12, 16, 20], fingerMcps = [2, 5, 9, 13, 17];
                    const fingerPips = [3, 6, 10, 14, 18]; // PIP joints for better curl detection
                    let fingersOpen = 0, openFingerTip = null;
                    
                    // Calculate palm center for better fist detection
                    const palmCenter = {
                        x: (lm[0].x + lm[5].x + lm[17].x) / 3,
                        y: (lm[0].y + lm[5].y + lm[17].y) / 3
                    };
                    
                    fingerTips.forEach((tip, idx) => {
                        const mcp = fingerMcps[idx];
                        const pip = fingerPips[idx];
                        
                        // Method 1: tip distance from wrist vs mcp distance
                        const tipDist = Math.hypot(lm[tip].x - wrist.x, lm[tip].y - wrist.y);
                        const mcpDist = Math.hypot(lm[mcp].x - wrist.x, lm[mcp].y - wrist.y);
                        
                        // Method 2: check if finger is curled (tip closer to palm than pip)
                        const tipToPalm = Math.hypot(lm[tip].x - palmCenter.x, lm[tip].y - palmCenter.y);
                        const pipToPalm = Math.hypot(lm[pip].x - palmCenter.x, lm[pip].y - palmCenter.y);
                        
                        // Finger is open if: tip is far from wrist AND tip is farther from palm than pip
                        const isExtended = tipDist > mcpDist * 1.3;
                        const isNotCurled = tipToPalm > pipToPalm * 0.9;
                        
                        if (isExtended && isNotCurled) { 
                            fingersOpen++; 
                            openFingerTip = lm[tip]; 
                        }
                    });
                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                    if (fingersOpen === 1 && openFingerTip) {
                        newState = 'POINTING';
                        const fingerDirX = openFingerTip.x - wrist.x;
                        const fingerDirY = openFingerTip.y - wrist.y;
                        if (fingerDirX < -0.08) pointDirectionX = 1;
                        else if (fingerDirX > 0.08) pointDirectionX = -1;
                        if (fingerDirY < -0.08) pointDirectionY = -1;
                        else if (fingerDirY > 0.08) pointDirectionY = 1;
                    } else if (fingersOpen <= 1) newState = 'TREE';
                    else if (pinchDist < 0.06) newState = 'PHOTO';
                    else newState = 'EXPLODE';
                }
            }
            stateBuffer.push(newState);
            if (stateBuffer.length > STATE_BUFFER_SIZE) stateBuffer.shift();
            const stateCount = {};
            stateBuffer.forEach(s => stateCount[s] = (stateCount[s] || 0) + 1);
            const dominant = Object.entries(stateCount).sort((a,b) => b[1] - a[1])[0];
            if (dominant && dominant[1] >= 3) state = dominant[0];
            const dirXStr = pointDirectionX === 1 ? 'R' : pointDirectionX === -1 ? 'L' : '-';
            const dirYStr = pointDirectionY === 1 ? 'D' : pointDirectionY === -1 ? 'U' : '-';
            document.getElementById('debug').innerHTML = 'State: ' + state + '<br>Dir: ' + dirXStr + '/' + dirYStr + '<br>FPS: ' + (1/te).toFixed(0);
            requestAnimationFrame(detectHands);
        }

        function init3D() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.002);
            camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
            camera.position.z = 100;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setClearColor(0x050510);
            renderer.setSize(innerWidth, innerHeight);
            renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            groupGold = createParticles('gold', CONFIG.goldCount, 2.0);
            groupRed = createParticles('red', CONFIG.redCount, 3.5);
            groupGift = createParticles('gift', CONFIG.giftCount, 3.0);
            createPhotos();
            createDecorations();
            animate();
        }

        // Rainbow color helper
        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) { r = g = b = l; }
            else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r, g, b };
        }

        function createParticles(type, count, size) {
            const positions = [], treeTargets = [], explodeTargets = [], heartTargets = [], phases = [];
            for (let i = 0; i < count; i++) {
                const h = Math.random() * CONFIG.treeHeight;
                const y = h - CONFIG.treeHeight / 2;
                const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeBaseRadius;
                const r = maxR * (type === 'gold' ? Math.sqrt(Math.random()) : 0.9 + Math.random() * 0.1);
                const theta = Math.random() * Math.PI * 2;
                treeTargets.push(r * Math.cos(theta), y, r * Math.sin(theta));
                const phi = Math.acos(2 * Math.random() - 1);
                const lam = Math.random() * Math.PI * 2;
                const rad = CONFIG.explodeRadius * Math.cbrt(Math.random()) * (type === 'gift' ? 1.2 : 1);
                explodeTargets.push(rad * Math.sin(phi) * Math.cos(lam), rad * Math.sin(phi) * Math.sin(lam), rad * Math.cos(phi));
                const t = Math.random() * Math.PI * 2;
                let hx = 16 * Math.pow(Math.sin(t), 3);
                let hy = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                const fill = Math.pow(Math.random(), 0.3);
                heartTargets.push(hx * fill * 2.2, hy * fill * 2.2 + 5, (Math.random() - 0.5) * 8 * fill);
                positions.push(...treeTargets.slice(-3));
                phases.push(Math.random() * Math.PI * 2);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const colors = new Float32Array(count * 3);
            // RAINBOW: Start with white, will be animated
            for (let i = 0; i < count; i++) { colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1; }
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.userData = { tree: treeTargets, explode: explodeTargets, heart: heartTargets, phases, baseSize: size };
            const mat = new THREE.PointsMaterial({ size, map: textures[type], transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, sizeAttenuation: true });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            return points;
        }

        function createPhotos() {
            const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            for (let i = 0; i < PHOTO_COUNT; i++) {
                const texture = photoTextures[i];
                const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                
                // Create placeholder mesh, will be updated when texture loads
                const geo = new THREE.PlaneGeometry(8, 8);
                const mesh = new THREE.Mesh(geo, mat);
                
                // Create border placeholder
                const borderGeo = new THREE.PlaneGeometry(9, 9);
                const border = new THREE.Mesh(borderGeo, borderMat.clone());
                border.position.z = -0.1;
                mesh.add(border);
                mesh.visible = false;
                mesh.scale.set(0, 0, 0);
                scene.add(mesh);
                photoMeshes.push(mesh);
                
                // Update geometry when texture loads to match aspect ratio
                texture.onUpdate = function() {
                    if (texture.image) {
                        const img = texture.image;
                        const aspect = img.width / img.height;
                        const baseSize = 8;
                        let width, height;
                        
                        if (aspect > 1) {
                            // Landscape
                            width = baseSize;
                            height = baseSize / aspect;
                        } else {
                            // Portrait or square
                            width = baseSize * aspect;
                            height = baseSize;
                        }
                        
                        // Update photo geometry
                        mesh.geometry.dispose();
                        mesh.geometry = new THREE.PlaneGeometry(width, height);
                        
                        // Update border geometry
                        border.geometry.dispose();
                        border.geometry = new THREE.PlaneGeometry(width + 1, height + 1);
                    }
                };
            }
        }

        function createDecorations() {
            const c1 = document.createElement('canvas');
            c1.width = 1024; c1.height = 256;
            const ctx1 = c1.getContext('2d');
            ctx1.font = 'bold italic 90px "Times New Roman"';
            const grad1 = ctx1.createLinearGradient(0, 0, 1024, 0);
            grad1.addColorStop(0, '#ff0000'); grad1.addColorStop(0.17, '#ff8800');
            grad1.addColorStop(0.33, '#ffff00'); grad1.addColorStop(0.5, '#00ff00');
            grad1.addColorStop(0.67, '#0088ff'); grad1.addColorStop(0.83, '#8800ff');
            grad1.addColorStop(1, '#ff0000');
            ctx1.fillStyle = grad1; ctx1.textAlign = 'center';
            ctx1.shadowColor = '#FFF'; ctx1.shadowBlur = 20;
            ctx1.fillText('MERRY CHRISTMAS', 512, 130);
            titleMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 15), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c1), transparent: true, blending: THREE.AdditiveBlending }));
            titleMesh.position.set(0, 50, 0);
            scene.add(titleMesh);
            
            const c2 = document.createElement('canvas');
            c2.width = c2.height = 128;
            const ctx2 = c2.getContext('2d');
            ctx2.fillStyle = '#FFF'; ctx2.shadowColor = '#FFF'; ctx2.shadowBlur = 20;
            ctx2.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx2.lineTo(64 + Math.cos((18 + i*72) * Math.PI/180) * 50, 64 - Math.sin((18 + i*72) * Math.PI/180) * 50);
                ctx2.lineTo(64 + Math.cos((54 + i*72) * Math.PI/180) * 20, 64 - Math.sin((54 + i*72) * Math.PI/180) * 20);
            }
            ctx2.closePath(); ctx2.fill();
            starMesh = new THREE.Mesh(new THREE.PlaneGeometry(12, 12), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c2), transparent: true, blending: THREE.AdditiveBlending }));
            starMesh.position.set(0, CONFIG.treeHeight/2 + 2, 0);
            scene.add(starMesh);
            
            // Love text with word wrap and background (Rainbow Magic theme)
            const c3 = document.createElement('canvas');
            c3.width = 1024; c3.height = 512;
            const ctx3 = c3.getContext('2d');
            
            // Rainbow gradient for text
            const grad3 = ctx3.createLinearGradient(100, 0, 924, 0);
            grad3.addColorStop(0, '#ff69b4'); grad3.addColorStop(0.5, '#ff1493'); grad3.addColorStop(1, '#ff69b4');
            
            // Text settings
            ctx3.fillStyle = grad3;
            ctx3.textAlign = 'center';
            ctx3.textBaseline = 'middle';
            ctx3.shadowColor = '#FFF';
            ctx3.shadowBlur = 30;
            
            // Word wrap function
            function wrapText(ctx, text, maxWidth, fontSize) {
                ctx.font = `bold ${fontSize}px "Segoe UI"`;
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && currentLine) {
                        lines.push(currentLine);
                        currentLine = word;
                    } else {
                        currentLine = testLine;
                    }
                }
                if (currentLine) lines.push(currentLine);
                return lines;
            }
            
            // Calculate font size and wrap text
            let fontSize = 80;
            let lines = wrapText(ctx3, LOVE_TEXT, 850, fontSize);
            
            // Reduce font size if too many lines
            while (lines.length > 4 && fontSize > 40) {
                fontSize -= 10;
                lines = wrapText(ctx3, LOVE_TEXT, 850, fontSize);
            }
            
            // Draw wrapped text
            ctx3.font = `bold ${fontSize}px "Segoe UI"`;
            const lineHeight = fontSize * 1.3;
            const totalHeight = lines.length * lineHeight;
            const startY = 256 - totalHeight / 2 + lineHeight / 2;
            
            lines.forEach((line, i) => {
                ctx3.fillText(line, 512, startY + i * lineHeight);
            });
            
            loveMesh = new THREE.Mesh(new THREE.PlaneGeometry(70, 35), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(c3), transparent: true }));
            loveMesh.position.set(0, 5, 25);
            loveMesh.visible = false;
            scene.add(loveMesh);
        }

        function updateParticles(group, type, targetState, speed, time) {
            const pos = group.geometry.attributes.position.array;
            const colors = group.geometry.attributes.color.array;
            const { tree, explode, heart, phases } = group.geometry.userData;
            const targets = targetState === 'TREE' ? tree : targetState === 'HEART' ? heart : explode;
            for (let i = 0; i < pos.length; i++) pos[i] += (targets[i] - pos[i]) * speed;
            group.geometry.attributes.position.needsUpdate = true;
            const count = pos.length / 3;
            if (targetState === 'TREE') {
                const breathe = 1 + Math.sin(time * 0.8) * 0.03;
                group.scale.set(breathe, breathe, breathe);
                group.rotation.x = 0; group.rotation.y = 0; group.rotation.z = 0; group.position.y = 0;
            } else if (targetState === 'HEART') {
                group.rotation.x *= 0.9; group.rotation.y *= 0.9;
                const beat = 1 + Math.abs(Math.sin(time * 3)) * 0.15;
                group.scale.set(beat, beat, beat);
            } else {
                group.scale.set(1, 1, 1);
                group.rotation.y += currentRotationSpeedY;
                group.rotation.x += currentRotationSpeedX;
            }
            // RAINBOW: Dynamic color cycling per particle
            for (let i = 0; i < count; i++) {
                const hue = (time * 0.3 + phases[i] / (Math.PI * 2)) % 1;
                const rgb = hslToRgb(hue, 1, 0.6);
                const b = targetState === 'TREE' ? 0.7 + 0.3 * Math.sin(time * 5 + phases[i]) : 0.6 + 0.4 * Math.sin(time * 8 + phases[i]);
                colors[i*3] = rgb.r * b; colors[i*3+1] = rgb.g * b; colors[i*3+2] = rgb.b * b;
            }
            group.geometry.attributes.color.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            let targetSpeedY = 0, targetSpeedX = 0;
            if (state === 'POINTING') {
                if (pointDirectionX !== 0) targetSpeedY = pointDirectionX * 0.008;
                if (pointDirectionY !== 0) targetSpeedX = pointDirectionY * 0.006;
            }
            currentRotationSpeedY = currentRotationSpeedY * 0.95 + targetSpeedY * 0.05;
            currentRotationSpeedX = currentRotationSpeedX * 0.95 + targetSpeedX * 0.05;
            const visualState = (state === 'POINTING') ? 'EXPLODE' : state;
            updateParticles(groupGold, 'gold', visualState, 0.08, time);
            updateParticles(groupRed, 'red', visualState, 0.08, time);
            updateParticles(groupGift, 'gift', visualState, 0.08, time);
            
            // Rainbow star color
            if (starMesh) {
                const hue = (time * 0.5) % 1;
                const rgb = hslToRgb(hue, 1, 0.7);
                starMesh.material.color.setRGB(rgb.r, rgb.g, rgb.b);
            }
            
            if (state === 'TREE') {
                titleMesh.visible = starMesh.visible = true; loveMesh.visible = false;
                titleMesh.scale.lerp(new THREE.Vector3(1,1,1), 0.1);
                starMesh.rotation.z -= 0.02;
                starMesh.material.opacity = 0.7 + 0.3 * Math.sin(time * 5);
                photoMeshes.forEach(m => { m.visible = false; m.scale.lerp(new THREE.Vector3(0,0,0), 0.1); });
            } else if (state === 'HEART') {
                titleMesh.visible = starMesh.visible = false; loveMesh.visible = true;
                photoMeshes.forEach(m => m.visible = false);
                const s = 1 + Math.abs(Math.sin(time * 3)) * 0.1;
                loveMesh.scale.set(s, s, 1);
            } else if (state === 'EXPLODE' || state === 'POINTING') {
                titleMesh.visible = starMesh.visible = loveMesh.visible = false;
                // Dynamic orbit radius based on photo count
                const dynamicRadius = CONFIG.photoOrbitRadius + Math.max(0, (PHOTO_COUNT - 5) * 2);
                // Dynamic photo scale (smaller photos when there are many)
                const basePhotoScale = PHOTO_COUNT <= 5 ? 1 : Math.max(0.5, 1 - (PHOTO_COUNT - 5) * 0.04);
                let bestIdx = 0, maxZ = -999;
                
                // Apply rotation from pointing gesture
                const rotY = groupGold.rotation.y;
                const rotX = groupGold.rotation.x;
                
                photoMeshes.forEach((m, i) => {
                    m.visible = true;
                    
                    // Fibonacci sphere distribution for even spacing
                    const phi = Math.acos(1 - 2 * (i + 0.5) / PHOTO_COUNT);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i;
                    
                    // Base position on sphere
                    let x = Math.sin(phi) * Math.cos(theta) * dynamicRadius;
                    let y = Math.sin(phi) * Math.sin(theta) * dynamicRadius;
                    let z = Math.cos(phi) * dynamicRadius;
                    
                    // Apply rotation from gesture
                    const cosY = Math.cos(rotY), sinY = Math.sin(rotY);
                    const cosX = Math.cos(rotX), sinX = Math.sin(rotX);
                    
                    // Rotate around Y axis
                    const x1 = x * cosY + z * sinY;
                    const z1 = -x * sinY + z * cosY;
                    
                    // Rotate around X axis
                    const y2 = y * cosX - z1 * sinX;
                    const z2 = y * sinX + z1 * cosX;
                    
                    m.position.lerp(new THREE.Vector3(x1, y2, z2), 0.1);
                    m.lookAt(camera.position);
                    
                    if (z2 > maxZ) { maxZ = z2; bestIdx = i; }
                    const scale = (z2 > 0 ? 0.8 + (z2 / dynamicRadius) * 0.6 : 0.4) * basePhotoScale;
                    m.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.1);
                });
                selectedIndex = bestIdx;
            } else if (state === 'PHOTO') {
                loveMesh.visible = false;
                photoMeshes.forEach((m, i) => {
                    if (i === selectedIndex) { m.position.lerp(new THREE.Vector3(0, 0, 60), 0.1); m.scale.lerp(new THREE.Vector3(5, 5, 5), 0.1); m.lookAt(camera.position); }
                    else m.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                });
            }
            renderer.render(scene, camera);
        }

        async function startSystem() {
            document.getElementById('welcome-screen').classList.add('hidden');
            document.getElementById('debug').style.display = 'block';
            document.getElementById('camera-preview').classList.add('visible');
            document.getElementById('debug-btn').style.display = 'block';
            document.querySelector('.mini-guide').style.display = 'block';
            createMainSnowflakes();
            
            // Load YouTube IFrame API if video ID is provided, otherwise use default audio
            if (typeof YOUTUBE_VIDEO_ID !== 'undefined' && YOUTUBE_VIDEO_ID) {
                var tag = document.createElement('script');
                tag.src = 'https://www.youtube.com/iframe_api';
                var firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            } else {
                // Fallback to default audio
                var music = new Audio('../audio.mp3');
                music.loop = true;
                music.volume = 0.7;
                music.play().catch(function() {});
            }
            
            init3D();
            await initHandDetection();
        }

        // YouTube IFrame API
        var ytPlayer = null;
        function onYouTubeIframeAPIReady() {
            if (typeof YOUTUBE_VIDEO_ID !== 'undefined' && YOUTUBE_VIDEO_ID) {
                ytPlayer = new YT.Player('youtube-player', {
                    height: '0',
                    width: '0',
                    videoId: YOUTUBE_VIDEO_ID,
                    playerVars: {
                        autoplay: 1,
                        loop: 1,
                        playlist: YOUTUBE_VIDEO_ID,
                        controls: 0,
                        showinfo: 0,
                        modestbranding: 1,
                        fs: 0,
                        cc_load_policy: 0,
                        iv_load_policy: 3,
                        autohide: 1
                    },
                    events: {
                        onReady: function(event) {
                            event.target.setVolume(70);
                            event.target.playVideo();
                        },
                        onError: function(event) {
                            console.log('YouTube player error:', event.data);
                        }
                    }
                });
            }
        }

        function createMainSnowflakes() {
            const container = document.getElementById('main-snowflakes');
            container.style.display = 'block';
            const flakes = ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº', '‚òÖ', '‚ú¶'];
            const count = window.innerWidth < 480 ? 40 : window.innerWidth < 768 ? 60 : 80;
            for (let i = 0; i < count; i++) {
                const flake = document.createElement('div');
                flake.className = 'snowflake';
                flake.textContent = flakes[Math.floor(Math.random() * flakes.length)];
                flake.style.left = Math.random() * 100 + '%';
                flake.style.animationDuration = (Math.random() * 6 + 4) + 's';
                flake.style.animationDelay = Math.random() * 3 + 's';
                flake.style.fontSize = (Math.random() * 1.2 + 0.5) + 'em';
                flake.style.opacity = Math.random() * 0.6 + 0.2;
                container.appendChild(flake);
            }
        }

        let debugVisible = true;
        function toggleDebug() {
            debugVisible = !debugVisible;
            const btn = document.getElementById('debug-btn');
            const debug = document.getElementById('debug');
            const camera = document.getElementById('camera-preview');
            if (debugVisible) {
                btn.textContent = 'ON';
                btn.className = 'on';
                debug.classList.remove('debug-hidden');
                camera.classList.remove('debug-hidden');
            } else {
                btn.textContent = 'OFF';
                btn.className = 'off';
                debug.classList.add('debug-hidden');
                camera.classList.add('debug-hidden');
            }
        }

        function createSnowflakes() {
            const container = document.querySelector('.snowflakes');
            const flakes = ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚úª', '‚úº', '‚òÖ', '‚ú¶'];
            for (let i = 0; i < 50; i++) {
                const flake = document.createElement('div');
                flake.className = 'snowflake';
                flake.textContent = flakes[Math.floor(Math.random() * flakes.length)];
                flake.style.left = Math.random() * 100 + '%';
                flake.style.animationDuration = (Math.random() * 5 + 5) + 's';
                flake.style.animationDelay = Math.random() * 5 + 's';
                flake.style.fontSize = (Math.random() * 1 + 0.5) + 'em';
                flake.style.opacity = Math.random() * 0.5 + 0.3;
                container.appendChild(flake);
            }
        }
        createSnowflakes();
        window.addEventListener('resize', () => { if (camera) { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); } });
    </script>
</body>
</html>